// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 8,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected once all files have been processed (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected once all files have been processed (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        0,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is one functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is one replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected once all files have been processed (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected once all files have been processed (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        0,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is two functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is two replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected once all files have been processed (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected once all files have been processed (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        0,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero functions as expected when a file was removed 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "REMOVE_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero functions as expected when a file was updated 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 8,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is one functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is one functions as expected when a file was removed 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "REMOVE_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is one functions as expected when a file was updated 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is one replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is one when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is two functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is two functions as expected when a file was removed 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "REMOVE_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is two functions as expected when a file was updated 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is two replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source does not have trailing separator when watch mode enabled when worker count is two when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count argument is zero functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count argument is zero replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 8,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected once all files have been processed (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected once all files have been processed (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        0,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is one functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is one replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected once all files have been processed (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected once all files have been processed (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        0,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is two functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is two replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected once all files have been processed (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected once all files have been processed (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        0,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count argument is zero functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count argument is zero functions as expected when a file was removed 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "REMOVE_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count argument is zero functions as expected when a file was updated 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count argument is zero replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 8,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count argument is zero when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is one functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is one functions as expected when a file was removed 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "REMOVE_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is one functions as expected when a file was updated 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is one replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is one when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is two functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is two functions as expected when a file was removed 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "REMOVE_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is two functions as expected when a file was updated 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is two replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when not verbose when source has trailing separator when watch mode enabled when worker count is two when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": false,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 8,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected once all files have been processed (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 7 idle",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected once all files have been processed (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 7 idle",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        0,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 7 idle",
      ],
      Array [
        "Sending action to worker 7",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 7 idle",
      ],
      Array [
        "Sending action to worker 7",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count argument is zero when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is one functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is one replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected once all files have been processed (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 1 idle",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected once all files have been processed (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 1 idle",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        0,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 1 idle",
      ],
      Array [
        "Sending action to worker 1",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 1 idle",
      ],
      Array [
        "Sending action to worker 1",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is one when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is two functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is two replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected once all files have been processed (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 2 idle",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected once all files have been processed (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 2 idle",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        0,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 2 idle",
      ],
      Array [
        "Sending action to worker 2",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 2 idle",
      ],
      Array [
        "Sending action to worker 2",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode disabled when worker count is two when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero functions as expected when a file was removed 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "REMOVE_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero functions as expected when a file was updated 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 8,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 7 idle",
      ],
      Array [
        "Sending action to worker 7",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 7 idle",
      ],
      Array [
        "Sending action to worker 7",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count argument is zero when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is one functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is one functions as expected when a file was removed 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "REMOVE_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is one functions as expected when a file was updated 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is one replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 1 idle",
      ],
      Array [
        "Sending action to worker 1",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 1 idle",
      ],
      Array [
        "Sending action to worker 1",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is one when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is two functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is two functions as expected when a file was removed 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "REMOVE_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is two functions as expected when a file was updated 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is two replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 2 idle",
      ],
      Array [
        "Sending action to worker 2",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 2 idle",
      ],
      Array [
        "Sending action to worker 2",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source does not have trailing separator when watch mode enabled when worker count is two when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count argument is zero functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count argument is zero replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 8,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected once all files have been processed (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 7 idle",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected once all files have been processed (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 7 idle",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        0,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 7 idle",
      ],
      Array [
        "Sending action to worker 7",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 7 idle",
      ],
      Array [
        "Sending action to worker 7",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count argument is zero when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is one functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is one replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected once all files have been processed (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 1 idle",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected once all files have been processed (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 1 idle",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        0,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 1 idle",
      ],
      Array [
        "Sending action to worker 1",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 1 idle",
      ],
      Array [
        "Sending action to worker 1",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is one when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is two functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is two replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected once all files have been processed (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 2 idle",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected once all files have been processed (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 2 idle",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        0,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": true,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 2 idle",
      ],
      Array [
        "Sending action to worker 2",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 2 idle",
      ],
      Array [
        "Sending action to worker 2",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode disabled when worker count is two when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": false,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction],
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count argument is zero functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count argument is zero functions as expected when a file was removed 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "REMOVE_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count argument is zero functions as expected when a file was updated 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count argument is zero replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 8,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 7 idle",
      ],
      Array [
        "Sending action to worker 7",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 7 idle",
      ],
      Array [
        "Sending action to worker 7",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count argument is zero when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count argument is zero when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 7 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 4,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 5,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 6,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 7,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is one functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is one functions as expected when a file was removed 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "REMOVE_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is one functions as expected when a file was updated 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is one replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 1 idle",
      ],
      Array [
        "Sending action to worker 1",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 1 idle",
      ],
      Array [
        "Sending action to worker 1",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is one when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is one when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 1 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is two functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is two functions as expected when a file was removed 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "REMOVE_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is two functions as expected when a file was updated 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/alpha.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is two replaces dead worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Worker 1 died, spawning a new worker in it's place",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 3,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 2 idle",
      ],
      Array [
        "Sending action to worker 2",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": true,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker for idle action type (not erred) 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
      Array [
        "Worker 2 idle",
      ],
      Array [
        "Sending action to worker 2",
        "{\\"filePath\\":\\"/foo/bar.js\\",\\"type\\":\\"TRANSFORM_FILE\\"}",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction] {
            "calls": Array [
              Array [
                Object {
                  "filePath": "/foo/bar.js",
                  "type": "TRANSFORM_FILE",
                },
              ],
            ],
          },
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives message from worker of unkown action type 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Worker sent message with unknown action type FOOBAR",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives non-object message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be an object but instead received type string",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is two when glob succeeds with files functions as expected when it receives null message from worker 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction] {
    "calls": Array [
      Array [
        "Expected message from worker to be present but instead received null",
      ],
    ],
  },
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 4 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction] {
    "calls": Array [
      Array [
        1,
      ],
    ],
  },
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [
      Object {
        "filePath": "/foo/bar.js",
        "type": "TRANSFORM_FILE",
      },
      Object {
        "filePath": "/foo/baz.js",
        "type": "TRANSFORM_FILE",
      },
    ],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;

exports[`master when verbose when source has trailing separator when watch mode enabled when worker count is two when glob succeeds without files functions as expected 1`] = `
Object {
  "clusterFork": [MockFunction] {
    "calls": Array [
      Array [],
      Array [],
    ],
  },
  "clusterOn": [MockFunction] {
    "calls": Array [
      Array [
        "exit",
        [Function],
      ],
    ],
  },
  "consoleError": [MockFunction],
  "consoleInfo": [MockFunction] {
    "calls": Array [
      Array [
        "Spawned 2 workers",
      ],
      Array [
        "Queuing up 0 files to be processed",
      ],
    ],
  },
  "glob": [MockFunction] {
    "calls": Array [
      Array [
        "/foo/**/*",
        [Function],
      ],
    ],
  },
  "processExit": [MockFunction],
  "state": Object {
    "erred": false,
    "isWatching": true,
    "queue": Array [],
    "verbose": true,
    "workers": Array [
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 1,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
      Object {
        "idle": false,
        "worker": Object {
          "_trigger": [Function],
          "id": 2,
          "on": [MockFunction] {
            "calls": Array [
              Array [
                "message",
                [Function],
              ],
            ],
          },
          "send": [MockFunction],
        },
      },
    ],
  },
  "watch": [MockFunction] {
    "calls": Array [
      Array [
        "/foo",
        Object {
          "recursive": true,
        },
        [Function],
      ],
    ],
  },
}
`;
